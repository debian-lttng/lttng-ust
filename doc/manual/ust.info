This is ust.info, produced by makeinfo version 4.13 from manual.texinfo.

This manual is for program, version version.

   Copyright (C)  copyright-owner.

     Permission is granted to ...


File: ust.info,  Node: Top,  Next: Overview,  Up: (dir)

LTTng Userspace Tracer
**********************

This manual is for UST 0.1.

* Menu:

* Overview::
* Installation::
* Quick start::
* Instrumenting an application::
* Recording a trace::
* Viewing traces::
* Performance::


File: ust.info,  Node: Overview,  Next: Installation,  Prev: Top,  Up: Top

1 Overview
**********

* Menu:

* License::
* Supported platforms::


File: ust.info,  Node: License,  Next: Supported platforms,  Up: Overview

1.1 License
===========

The LTTng Userspace Tracer is intended to be linkable to open source
software as well as to proprietary applications. This was accomplished
by licensing the code that needs to be linked to the traced program as
LGPL.

   Components licensed as LGPL v2.1:
   * libust

   * libinterfork

   * libustcomm

   Components licensed as GPL v2:
   * ustctl

   * libustcmd

   * ustd


File: ust.info,  Node: Supported platforms,  Prev: License,  Up: Overview

1.2 Supported platforms
=======================

UST can currently trace applications running on Linux, on the x86-32
and x86-64 architectures.


File: ust.info,  Node: Installation,  Next: Quick start,  Prev: Overview,  Up: Top

2 Installation
**************

The LTTng userspace tracer is a library and a set of userspace tools.

   The following packages are required:

   * ust

     This contains the tracing library, the ustd daemon, trace control
     tools and other helper tools.

     Repository: http://git.dorsal.polymtl.ca

   * libkcompat

     This is a library that contains a userspace port of some kernel
     APIs.

     Repository: http://git.dorsal.polymtl.ca

   * liburcu

     This is the userspace read-copy update library by Mathieu
     Desnoyers.

     Available in Debian as package liburcu-dev.

     Home page: http://lttng.org/?q=node/18

   * LTTV

     LTTV is a graphical (and text) viewer for LTTng traces.

     Home page: http://lttng.org


   Libkcompat and liburcu should be installed first. UST may then be
compiled and installed. LTTV has no dependency on the other packages;
it may therefore be installed on a system which does not have UST
installed.

   Refer to the README in each of these packages for installation
instructions.


File: ust.info,  Node: Quick start,  Next: Instrumenting an application,  Prev: Installation,  Up: Top

3 Quick start
*************

First, instrument a program with a marker.


     #include <ust/marker.h>

     int main(int argc, char **argv)
     {
     	int v;
     	char *st;

     	/* ... set values of v and st ... */

     	/* a marker: */
     	trace_mark(ust, myevent, "firstarg %d secondarg %s", v, st);

     	/* a marker without arguments: */
     	trace_mark(ust, myotherevent, MARK_NOARGS);

     	return 0;
     }

   Then compile it in the regular way, linking it with libust. For
example:

     gcc -o foo -lust foo.c

   Run the program with `usttrace'. The `usttrace' output says where
the trace was written.

     usttrace ./foo

   Finally, open the trace in LTTV.

     lttv-gui -t /path/to/trace

   The trace can also be dumped as text in the console:

     lttv -m textDump -t /path/to/trace


File: ust.info,  Node: Instrumenting an application,  Next: Recording a trace,  Prev: Quick start,  Up: Top

4 Instrumenting an application
******************************

In order to record a trace of events occurring in a application, the
application must be instrumented. Instrumentation points resemble
function calls. When the program reaches an instrumentation point, an
event is generated.

   There are no limitations on the type of code that may be
instrumented.  Multi-threaded programs may be instrumented without
problem. Signal handlers may be instrumented as well.

   There are two APIs to instrument programs: markers and tracepoints.
Markers are quick to add and are usually used for temporary
instrumentation. Tracepoints provide a way to instrument code more
cleanly and are suited for permanent instrumentation.

   In addition to executable programs, shared libraries may also be
instrumented with the methods described in this chapter.

* Menu:

* Markers::
* Tracepoints::


File: ust.info,  Node: Markers,  Next: Tracepoints,  Up: Instrumenting an application

4.1 Markers
===========

Adding a marker is simply a matter of insert one line in the program.

     #include <ust/marker.h>

     int main(int argc, char **argv)
     {
     	int v;
     	char *st;

     	/* ... set values of v and st ... */

     	/* a marker: */
     	trace_mark(main, myevent, "firstarg %d secondarg %s", v, st);

     	/* a marker without arguments: */
     	trace_mark(main, myotherevent, MARK_NOARGS);

     	return 0;
     }

   The invocation of the trace_mark() macro requires at least 3
arguments. The first, here "main", is the name of the event category.
It is also the name of the channel the event will go in. The second,
here "myevent" is the name of the event. The third is a format string
that announces the names and the types of the event arguments. Its
format resembles that of a printf() format string; it is described
thoroughly in Appendix x.

   A given Marker may appear more than once in the same program. Other
Markers may have the same name and a different format string, although
this might induce some confusion at analysis time.


File: ust.info,  Node: Tracepoints,  Prev: Markers,  Up: Instrumenting an application

4.2 Tracepoints
===============

The Tracepoints API uses the Markers, but provides a higher-level
abstraction.  Whereas the markers API provides limited type checking,
the Tracepoints API provides more thorough type checking and discharges
from the need to insert format strings directly in the code and to have
format strings appear more than once if a given marker is reused.

     Note Although this example uses _mychannel_ as the channel, the:
     only channel name currently supported with early tracing is *ust*.
     The `usttrace' tool always uses the early tracing mode. When using
     manual mode without early tracing, any channel name may be used.

   A function instrumented with a tracepoint looks like this:

     #include "tp.h"

     void function()
     {
     	int v;
     	char *st;

     	/* ... set values of v and st ... */

     	/* a tracepoint: */
     	trace_mychannel_myevent(v, st);
     }

   Another file, here tp.h, contains declarations for the tracepoint.

     #include <ust/tracepoint.h>

     DECLARE_TRACE(mychannel_myevent, TPPROTO(int v, char *st),
     	      TPARGS(v, st));

   A third file, here tp.c, contains definitions for the tracepoint.

     #include <ust/marker.h>
     #include "tp.h"

     DEFINE_TRACE(mychannel_myevent);

     void mychannel_myevent_probe(int v, char *st)
     {
     	trace_mark(mychannel, myevent, "v %d st %s", v, st);
     }

     static void __attribute__((constructor)) init()
     {
     	register_trace_mychannel_myevent(mychannel_myevent_probe);
     }

   Here, tp.h and tp.c could contain declarations and definitions for
other tracepoints. The constructor would contain other register_* calls.


File: ust.info,  Node: Recording a trace,  Next: Viewing traces,  Prev: Instrumenting an application,  Up: Top

5 Recording a trace
*******************

* Menu:

* Using `usttrace'::
* Setting up the recording manually::
* Using early tracing::
* Crash recovery::
* Tracing across `fork()' and `clone()'::
* Tracing programs and libraries that were not linked to libust::


File: ust.info,  Node: Using `usttrace',  Next: Setting up the recording manually,  Up: Recording a trace

5.1 Using `usttrace'
====================

The simplest way to record a trace is to use the `usttrace' script. An
example is given in the quickstart above.

   The `usttrace' script automatically:
   * creates a daemon

   * enables all markers

   * runs the command specified on the command line

   * after the command ends, prints the location where the trace was
     saved

   Each subdirectory of the save location contains the trace of one
process that was generated by the command. The name of a subdirectory
consists in the the PID of the process, followed by the timestamp of
its creation.

   The save location also contains logs of the tracing.

   When using `usttrace', the early tracing is always active, which
means that the tracing is guaranteed to be started by the time the
process enters its main() function.

   Several `usttrace''s may be run simultaneously without risk of
conflict. This facilitates the use of the tracer by idependent users on
a system. Each instance of `usttrace' starts its own daemon which
collects the events of the processes it creates.


File: ust.info,  Node: Setting up the recording manually,  Next: Using early tracing,  Prev: Using `usttrace',  Up: Recording a trace

5.2 Setting up the recording manually
=====================================

Instead of using `usttrace', a trace may be recorded on an already
running process.

   First the daemon must be started.

     # Make sure the directory for the communication sockets exists.
     $ mkdir /tmp/ustsocks

     # Make sure the directory where ustd will write the trace exists.
     $ mkdir /tmp/trace

     # Start the daemon
     $ ustd

     # We assume the program we want to trace is already running and that
     # it has pid 1234.

     # List the available markers
     $ ustctl --list-markers 1234
     # A column indicates 0 for an inactive marker and 1 for an active marker.

     # Enable a marker
     $ ustctl --enable-marker ust/mymark 1234

     # Create a trace
     $ ustctl --create-trace 1234

     # Start tracing
     $ ustctl --start-trace 1234

     # Do things...

     # Stop tracing
     $ ustctl --stop-trace 1234

     # Destroy the trace
     $ ustctl --destroy-trace 1234


File: ust.info,  Node: Using early tracing,  Next: Crash recovery,  Prev: Setting up the recording manually,  Up: Recording a trace

5.3 Using early tracing
=======================

Early tracing consists in starting the tracing as early as possible in
the program, so no events are lost between program start and the point
where the command to start the tracing is given. When using early
tracing, it is guaranteed that by the time the traced program enters
its `main()' function, the tracing will be started.

   When using `usttrace', the early tracing is always active.

   When using the manual mode (`ustctl'), early tracing is enabled using
environment variables. Setting `UST_TRACE' to `1', enables early
tracing, while setting `UST_AUTOPROBE' to `1' enables all markers
automatically.


File: ust.info,  Node: Crash recovery,  Next: Tracing across `fork()' and `clone()',  Prev: Using early tracing,  Up: Recording a trace

5.4 Crash recovery
==================

When a process being traced crashes, the daemon is able to recover all
the events in its buffers that were successfully commited. This is
possible because the buffers are in a shared memory segment which
remains available to the daemon even after the termination of the
traced process.


File: ust.info,  Node: Tracing across `fork()' and `clone()',  Next: Tracing programs and libraries that were not linked to libust,  Prev: Crash recovery,  Up: Recording a trace

5.5 Tracing across `fork()' and `clone()'
=========================================

Tracing across `clone()' when `CLONE_VM' is specified is supported
without any particular action.

   When `clone()' is called without `CLONE_VM' or `fork()' is called, a
new address space is created and the tracer must be notified to create
new buffers for it. *TODO: specify how to do it.*

   This can be done automatically (for `fork()' only for now), by
`LD_PRELOAD''ing `libinterfork.so'. This library intercepts calls to
`fork()' and informs the tracer it is being called. When using
`usttrace', this is accomplied by specifying the `-f' command line
argument.


File: ust.info,  Node: Tracing programs and libraries that were not linked to libust,  Prev: Tracing across `fork()' and `clone()',  Up: Recording a trace

5.6 Tracing programs and libraries that were not linked to libust
=================================================================

Todo.


File: ust.info,  Node: Performance,  Prev: Viewing traces,  Up: Top

6 Performance
*************

Todo.


File: ust.info,  Node: Viewing traces,  Next: Performance,  Prev: Recording a trace,  Up: Top

7 Viewing traces
****************



Tag Table:
Node: Top191
Node: Overview472
Node: License619
Node: Supported platforms1099
Node: Installation1321
Node: Quick start2454
Node: Instrumenting an application3375
Node: Markers4374
Node: Tracepoints5542
Node: Recording a trace7315
Node: Using `usttrace'7690
Node: Setting up the recording manually8884
Node: Using early tracing10015
Node: Crash recovery10812
Node: Tracing across `fork()' and `clone()'11277
Node: Tracing programs and libraries that were not linked to libust12112
Node: Performance12410
Node: Viewing traces12517

End Tag Table
