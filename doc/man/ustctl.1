.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "USTCTL" "1" "January 2011" "" ""
.
.SH "NAME"
\fBustctl\fR \- a program to control the tracing of userspace applications
.
.SH "SYNOPSIS"
\fBustctl\fR [\fICOMMAND\fR] [\fIARGS\fR]\.\.\.
.
.SH "DESCRIPTION"
\fBustctl\fR is a program to control the tracing of userspace applications\. It can list markers, start the tracing, stop the tracing, enable/disable markers, etc\.
.
.SH "OPTIONS"
These programs follow the usual GNU command line syntax, with long options starting with two dashes(`\-\')\. A summary of options is included below\.
.
.TP
\fB\-h\fR, \fB\-\-help\fR
Show summary of commands\.
.
.SH "COMMANDS"
\fBustctl\fR accepts commands followed by arguments for each respective command\. Most commands require the pid of the application being traced\.
.
.TP
\fBcreate\-trace\fR \fIPID\fR \fITRACE\fR
Create trace\.
.
.TP
\fBalloc\-trace\fR \fIPID\fR \fITRACE\fR
Allocate trace\.
.
.TP
\fBstart\-trace\fR \fIPID\fR \fITRACE\fR
Start tracing\.
.
.TP
\fBstop\-trace\fR \fIPID\fR \fITRACE\fR
Stop tracing\.
.
.TP
\fBdestroy\-trace\fR \fIPID\fR \fITRACE\fR
Destroy the trace\.
.
.TP
\fBset\-subbuf\-size\fR \fIPID\fR \fITRACE\fR \fICHANNEL\fR/\fIbytes\fR
Set the size of subbuffers in CHANNEL\.
.
.TP
\fBset\-subbuf\-num\fR \fIPID\fR \fITRACE\fR \fICHANNEL\fR/\fInr\fR
Set the number of subbuffers per buffer for CHANNEL\. Must be a power of 2\.
.
.TP
\fBset\-sock\-path\fR \fIPID\fR \fISOCKPATH\fR
Set the path of the daemon socket\.
.
.TP
\fBget\-subbuf\-size\fR \fIPID\fR \fITRACE\fR \fICHANNEL\fR
Print the size of subbuffers per buffer for CHANNEL\.
.
.TP
\fBget\-subbuf\-num\fR \fIPID\fR \fITRACE\fR \fICHANNEL\fR
Print the number of subbuffers per buffer for CHANNEL\.
.
.TP
\fBget\-sock\-path\fR \fIPID\fR
Get the path of the daemon socket\.
.
.TP
\fBenable\-marker\fR \fIPID\fR \fITRACE\fR \fICHANNEL\fR/\fIMARKER\fR
Enable a marker\.
.
.TP
\fBdisable\-marker\fR \fIPID\fR \fITRACE\fR \fICHANNEL\fR/\fIMARKER\fR
Disable a marker\.
.
.TP
\fBlist\-markers\fR \fIPID\fR
List the markers of the process, their state and format string\.
.
.TP
\fBforce\-subbuf\-switch\fR \fIPID\fR \fITRACE\fR
Force a subbuffer switch\. This will flush all the data currently held\.
.
.SH "LIFE CYCLE OF A TRACE"
Typically, the first step is to enable markers with \fBenable\-marker\fR\. An enabled marker generates an event when the control flow passes over it (assuming the trace is recording)\. A disabled marker produces nothing\. Enabling and disabling markers may however be done at any point, including while the trace is being recorded\.
.
.P
In order to record events, a trace is first created with \fBcreate\-trace\fR\. At this point, the subbuffer count and size may be changed with \fBset\-subbuf\-num\fR and \fBset\-subbuf\-size\fR\.
.
.P
Afterward, the trace may be allocated with \fBalloc\-trace\fR\. This allocates the buffers in memory, so once this is done, the subbuffer size and count can not be changed\. Trace allocation also causes the daemon to connect to the trace buffers and wait for data to arrive\. Explicit allocation is optional, as it is done automatically at trace start\.
.
.P
The trace may then be started with \fBstart\-trace\fR\. This results in events being recorded in the buffer\. The daemon automatically collects these events\.
.
.P
The trace may be stopped with \fBstop\-trace\fR, either definitely after all the wanted information is collected, or temporarily, before being started again with \fBstart\-trace\fR\. This results in effectively \'pausing\' the recording\. After using \fBstop\-trace\fR, if a daemon is collecting the trace, it may not have flushed to the disk the full contents of the buffer yet\.
.
.P
Finally, when \fBdestroy\-trace\fR is used, the trace buffers are unallocated\. However, the memory may not be effectively freed until the daemon finishes to collect them\. When the trace is being collected by \fBust\-consumerd\fR, this command guarantees its full contents is flushed to the disk\.
.
.SH "STRUCTURE OF A TRACE"
Each instrumentation point that is added in a program is associated to a channel\.
.
.P
Trace events are put in buffers\. There is one buffer per channel, per cpu\. For example, on a system with 4 cores and tracing an application with 3 channels, there will be 12 buffers in total\. The content of each of these buffers is put in a distinct file in the trace directory\. For example, the \fBmetadata_2\fR file contains the data that was extracted from the buffer that contained the events from the metadata channel and having occurred on cpu 2\.
.
.P
In memory, each buffer is divided in subbuffers\. Subbuffers are equally\-sized, contiguous parts of a buffer\. The size of a buffer is equal to the number of subbuffers it contains times the size of each subbuffer\. When a subbuffer is full, it is collected by the daemon while the others are filled\. If, however, the buffer size is too small, buffer overflows may occur and result in event loss\. By default, the number of subbuffers per buffer is 2\. Subbuffer size for a given channel may be chosen with \fBset\-subbuf\-size\fR while the subbuffer count is set with \fBset\-subbuf\-num\fR\.
.
.SH "SEE ALSO"
usttrace(1), ust\-consumerd(1)
.
.SH "AUTHOR"
\fBustctl\fR was written by Pierre\-Marc Fournier\.
.
.P
This manual page was written by Jon Bernard <jbernard@debian\.org>, for the Debian project (and may be used by others)\. It was updated by Pierre\-Marc Fournier\.
